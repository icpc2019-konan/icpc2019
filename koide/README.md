# icpc2019
ICPC2019の解答例


# 問題A：期末試験の成績

私は，中学校の教師である． ちょうど期末試験が終わったところで，すべての科目について全生徒の点数が手元にある． どれぐらい高い合計点を得た生徒がいるのか知りたいのだが，科目ごとの得点データになっているので，作業が容易でない． そこで，優秀なプログラマであるあなたに手助けしてほしい． 具体的には，合計点が最も高い生徒の合計点を求めるプログラムを書いてほしい．

### Input
入力は複数のデータセットからなる． 各データセットは次の形式で表される．
```
n m  
p1,1 p1,2 … p1,n  
p2,1 p2,2 … p2,n  
…  
pm,1 pm,2 … pm,n  
```

データセットの最初の行は，二つの整数 n と m からなる． n は生徒の人数 (1 ≤ n ≤ 1000)，m は科目数 (1 ≤ m ≤ 50) である． それに続く m 行のそれぞれには，特定の科目に対する n 人の生徒の得点がある． pj,k は，生徒 k の科目 j に対する得点を表す整数である (1 ≤ j ≤ m，1 ≤ k ≤ n)． この値は，0 ≤ pj,k ≤ 1000 を満たす．

入力の終わりは二つのゼロからなる行で表される． データセットの個数は 100 を超えない．

### Output
各データセットについて，合計点が最も高い生徒の合計点を出力せよ． 生徒 k の合計点 sk とは sk = p1,k + … + pm,k のことである．

### Sample Input
```
5 2  
10 20 30 40 50  
15 25 35 45 55  
6 3  
10 20 30 15 25 35  
21 34 11 52 20 18  
31 15 42 10 21 19  
4 2  
0 0 0 0  
0 0 0 0  
0 0  
```

### Output for the Sample Input
```
105  
83  
0  
```

## 方針  

入力データが何を表しているか，何を出力するかを，確実に理解しよう．  
今回のデータは，m行の各行に各科目の得点があり，左から生徒1，生徒2，．．．，生徒nの得点になっている．  
出力するのは，合計点の最も高い生徒の得点なので，列ごとの合計を求め，その最大値を表示すればよい．

プログラムに不慣れな人は，変数や配列・リスト等に値を代入する処理を作成するタイミングで，正しく値が格納されているか，画面表示して確認することをお勧めする（以下のプログラムでも，あちこちで確認している．最終的にはコメントアウトすればよい）


```python
while True:
    n, m = list(map(int, input().split()))
    # print(n, m)

    if n == 0 and m == 0:
        break

    p = []
    for i in range(m):
        p.append(list(map(int, input().split())))
    # print(p)

    total = [0] * n   # 各生徒の合計点数の初期化
    for i in range(m):
        for j in range(n):
            total[j] += p[i][j]
    # print(total)

    print(max(total))

```

# 問題B：スクリーンキーボード

リモコンでスクリーンキーボードを操作して文字列を入力したい. リモコンには 4 方向の矢印と OK のボタンがついている（図 B-1）． 与えられた文字列を与えられたスクリーンキーボードで入力するのに必要な最小ボタン押下回数を求めよ.

<img src="ICPC2019-B1.png" width="25%">
図 B-1 リモコン

<img src="ICPC2019-B2.png" width="25%">
図 B-2 スクリーンキーボードの例

|入力する文字  |強調表示の動き  |ボタン操作  |
|:-:|:-:|:-:|
|I  |<img src="ICPC2019-B3.png" width="75%">  |→,→,→,→,→,→,→,→,OK（9回）  |
|C  |<img src="ICPC2019-B4.png" width="75%"> |←,←,←,←,←,←,OK（7回）  |
|P  |<img src="ICPC2019-B5.png" width="75%">  |↓,→,→,→,→,OK（6回）  |
|C  |<img src="ICPC2019-B6.png" width="75%">  |↑,←,←,←,←,OK（6回）  |
	
図 B-3 図 B-2 のスクリーンキーボードで “ICPC” を入力する最短の手順

スクリーンキーボードは格子状に並んだセルからなり, 各セルには文字がひとつあるか空である. 複数のセルが同じ文字を含むことはない．

スクリーンキーボードのセルのひとつは強調表示されていて, 空でないセルが強調表示されているときにリモコンの OK ボタンを押すと, そのセルの文字が入力される.

最初はスクリーンキーボードの左上隅のセルが強調されている． 矢印ボタンのひとつを押すと, 強調セルはその矢印の示す方向の隣のセルに移る. 強調セルがスクリーンキーボードの端にあるときには, スクリーンキーボードから出るような方向の矢印ボタンを押しても何も起きない.

例えば図 B-2 に示すスクリーンキーボード上で文字列 “ICPC” を入力するには, 図 B-3 に示す手順でボタンを 28 回押せばよい. これが最小ボタン押下回数である.

スクリーンキーボードのセルに入っている文字は, 英小文字 (‘a’, ‘b’, ..., ‘z’)， 英大文字 (‘A’, ‘B’, ..., ‘Z’)， 数字 (‘0’, ‘1’, ..., ‘9’)， コンマ (‘,’)， ハイフン (‘-’)， ピリオド (‘.’)， スラッシュ (‘/’)， コロン (‘:’)， セミコロン (‘;’)， アットマーク (‘@’) のいずれかである．

### Input
入力は次の形式の最大 100 個のデータセットからなる．

```
h w  
r1  
...  
rh  
s  
```

データセットの最初の行のふたつの整数 h と w は，それぞれスクリーンキーボードの高さと幅である．これらは空白で区切られており, 1 ≤ h ≤ 50 と 1 ≤ w ≤ 50 を満たす.

続く h 行に，スクリーンキーボードの各行が与えられる． i 番目の行 ri はスクリーンキーボードの i 行目を表している． ri は長さ w の文字列であり，スクリーンキーボードの i 行目の文字が左から順に並んだものである． ただし，スクリーンキーボード上の空のセルは，アンダースコア (‘_’) で表現されている．

スクリーンキーボードは上述の条件を満たす．

続く行の s は，長さ 1 以上 1000 以下の，入力したい文字列である． s に含まれる文字は，必ず与えられたスクリーンキーボード上に存在する． s はアンダースコアを含まないことに注意．

入力の終わりはゼロふたつからなる行で表される．

### Output
各データセットについて，与えられた文字列を与えられたスクリーンキーボードで入力するのに必要な最小ボタン押下回数を表す整数ひとつをもつ行を出力せよ．

### Sample Input
```
3 9  
ABCDEFGHI  
JKLMNOPQR  
STUVWXYZ_  
ICPC  
5 11  
___________  
____A______  
________M__  
___________  
_C_________  
ACM  
4 21  
1_2_3_4_5_6_7_8_9_0_-  
QqWwEeRrTtYyUuIiOoPp@  
AaSsDdFfGgHhJjKkLl;_:  
ZzXxCcVvBbNnMm,_._/__  
ICPC2019,AsiaYokohamaRegional,QualificationRound  
0 0  
```

### Output for the Sample Input
```
28  
23  
493  
```

## 方針  
「複数のセルが同じ文字を含むことはない」ので，次の文字の位置を獲得し，現在の位置から移動するのに必要なボタン操作の回数を求める処理を繰り返せばよい．

カーソルの移動量は，移動前後の位置における横方向の差，および縦方向の差の合計になる（マンハッタン距離）．最後のOKボタンを押すことをお忘れなく．


```python
while True:
    h, w = list(map(int, input().split()))
    if h == 0 and w == 0:
        break
    # print(h, w)

    r = []
    for i in range(h):
        r.append(input())
    # print(r)

    s = input()
    # print(s)

    cx, cy = 0, 0   # カーソルの初期位置
    n_move = 0      # ボタンを押した回数
    for moji in s:  # 先頭文字から順にチェック
        for y in range(h):
            x = r[y].find(moji)
            # スクリーンキーボードの y行目 r[y] に 探している文字があるなら
            if x >= 0:
                n_move += ( abs(cx - x) + abs(cy - y) + 1)
                cx, cy = x, y
                break
    print(n_move)
```

# 問題C：天秤

実験化学者のあなたは粉末薬品の計量用に天秤ひとつと分銅のセットを持っている.

作業効率上, 1 回の計量には天秤を 1 回使うだけにしたい. セット中の分銅は同時にいくつ使ってもよく, 天秤の薬品と反対側に置いても同じ側に置いてもよい. たとえば 2 単位と 9 単位の分銅があれば, 2 単位, 9 単位だけでなく, 薬品と反対側に両方の分銅を置けば 11 単位 (図 C-1 左), 片方を薬品と同じ側に置けば 7 単位の薬品を量り取ることができる (図 C-1 右). 効率的に量り取れる量はこれらだけである.

<img src="ICPC2019-C.png" width="75%">
図 C-1 薬品 11 単位と 7 単位の計測法

手元に今日計量する薬品量のリストがある. しかし手持ちの分銅セットだけでは, 計量リスト中の量すべてを効率的に量れるとは限らない. その場合はもうひとつだけ分銅を買ってきて補ってもよいのだが, 重い分銅ほど高価なので, なるべく軽いもので済ませたい.

なお, どんな正の重さの分銅でも売っているが, 負の重さのものはない.

### Input
入力は次の形式の最大 100 個のデータセットからなる.

```
n m  
a1 a2 ... an  
w1 w2 ... wm  
```

データセットの最初の行の n と m は, それぞれ計量リスト中の薬品量の数とセット中の分銅の個数である. これらは空白で区切られており, 1 ≤ n ≤ 100 と 1 ≤ m ≤ 10 を満たす整数である.

次の行には計量リスト中の n 種の量 a1 から an が空白区切りで並ぶ. 各 ai は 1 ≤ ai ≤ $10^9$ を満たす整数で, i ≠ j ならば ai ≠ aj である.

データセットの最後の 3 行目には, 手持ちの m 個の分銅の重さ w1 から wm が空白区切りで並ぶ. 各 wj は 1 ≤ wj ≤ $10^8$ を満たす整数である. 分銅は同じ重さのものがいくつもあるかもしれない.

入力の終わりはゼロふたつからなる行で表される．

### Output
各データセットについて以下に指示する整数ひとつからなる 1 行を出力せよ.

- 分銅を追加せずに計量リスト中のすべての量が量り取れるなら 0.
- 分銅ひとつの追加で計量リスト中のすべての量が量り取れるようになるなら, そのような分銅のうちもっとも軽いものの重さ. 追加する分銅は $10^8$ より重くてもよい.
- 分銅ひとつの追加では計量リスト中のすべての量を量り取れるようにならないなら, -1.

### Sample Input
```
4 2  
9 2 7 11  
2 9  
6 2  
7 3 6 12 16 9  
2 9  
5 2  
7 3 6 12 17  
2 9  
7 5  
15 21 33 48 51 75 111  
36 54 57 93 113  
0 0  
```
  
### Output for the Sample Input
```
0  
5  
-1  
5  
```
  

## 方針  (2019/11/14 修正）
分銅の数 m の最大値が10と小さいので，分銅の数について総当たりしても問題ない点に注目する．

(1) 現在のm個の分銅で測定可能な重さを列挙する  
(2) 測定したい計量リスト a のうち，測定可能な重量を省く．ここでaが空になれば0を出力．  
(3) なおa内に残る測定不可能な各重量に対して，その重量を測定するために1つ追加すればよい分銅の重さ（複数存在する）の集合を設定する．  
(4) (3)で作成した集合の共通部分（積集合）が，a内の全重量を測定できる分銅の重さ．積集合が空集合なら-1を出力．1つでも存在すれば最軽量を出力．  


```python
while True:
    n, m = list(map(int, input().split()))
    if n == 0 and m == 0:
        break
    # print(n, m)

    a = set(map(int, input().split()))      # 測定したい重さ
    w = list(map(int, input().split()))     # 分銅の重さ
    # print('a =', a)
    # print('w =', w)

    # w で測定可能な重さ集合を作成
    possibles = {0}
    for e_w in w:
        tmp_possibles = possibles.copy()
        for e_possibles in possibles:
            tmp_possibles.add(e_w + e_possibles)        # ケース1
            tmp_possibles.add(abs(e_w - e_possibles))   # ケース2
        possibles = tmp_possibles
    possibles.discard(0)
    # print('possibles =', possibles)

    # 測定可能な重さを a から除去する
    a -= possibles
    if len(a) == 0:
        print(0)       # aのすべてがwで測定可能
        continue
    # print('left a =', a)

    # 現時点で測定できない重さを測るために，1つ追加する重さの候補集合
    add_w = {}

    # 測定できない各重さを測定できるように，追加する1つの重さの候補を順に絞る
    for e_a in a:   # 1つの重さ e_a に注目
        add_w_for_e_a = {e_a}     # e_aを測定するために，追加する1つの重さの候補集合
        for e_possibles in possibles:
            add_w_for_e_a.add(e_a + e_possibles)        # ケース1
            add_w_for_e_a.add(abs(e_a - e_possibles))   # ケース2

        if len(add_w) == 0:
            # e_aが最初の候補のとき　⇒　e_a用の候補が調査済み全重さに対する候補
            add_w = add_w_for_e_a
        else:
            # e_aが2番目以降の候補のとき　⇒　e_a用候補との積集合に絞る
            add_w &= add_w_for_e_a
            if len(add_w) == 0:
                break           # 調査済みのすべてを測定可能な重さがなければ，調査終了

    if len(add_w) == 0:         # 全て測定可能な重さがない
        print(-1)
    else:
        print(min(list(add_w)))
```

# 問題D：計数カウンタ

計数カウンタが何個か並んでいる． カウンタのボタンを押すと表示されている値が一つ増える． ただし，値が既に最大値なら，値は 1 に戻る． カウンタは全て同じモデルで最大値も同じである．

<img src="ICPC2019-D.png" width="25%">
図 D-1 計数カウンタ

各カウンタに表示されている値から始めて，各々について指定される目的の値に変えたい． しかし多数のカウンタのボタンを一つ一つ押していくのは面倒なので，特殊な道具を作った． これを使うと，1 回の操作で隣接する一連のカウンタのボタンを 1 回ずつ押せるのだ． 対象とするカウンタの範囲は，操作 1 回ごとにどこからどこまででも自由に決められる．

各カウンタに表示されている値を目的の値に変えるのに最低何回の操作が必要だろうか．

### Input
入力は複数のデータセットからなる． 各データセットは次の形式で表される．

```
n m   
a1 a2 ... an   
b1 b2 ... bn   
```
各データセットは 3 行からなる． 1 行目には，カウンタの個数を表す n (1 ≤ n ≤ 1000) と，カウンタに表示される最大値を表す m (1 ≤ m ≤ 10000) が与えられる． 2 行目には，各カウンタの最初の値を表す ai (1 ≤ ai ≤ m) が空白区切りで与えられる． 3 行目には，各カウンタの目的の値を表す bi (1 ≤ bi ≤ m) が空白区切りで与えられる．

入力の終わりは，二つのゼロからなる行で表される． データセットの個数は 100 を超えない．

### Output
各データセットについて，全てのカウンタにそれぞれ目的の値を表示させるのに必要な最小の操作回数を 1 行に出力せよ．

### Sample Input
```
4 5  
2 3 1 4  
2 5 5 2  
3 100  
1 10 100  
1 10 100  
5 10000  
4971 7482 1238 8523 1823  
3287 9013 9812 297 1809  
0 0  
```

### Output for the Sample Input
```
4  
0  
14731  
```

## 方針：  

DPで解く．目標の数値にするカウンタを左から順に1つずつ拡張させる．Sample Inputの3番目を使って例示しながら説明しよう．  

まず，現在の数値aと目標の数値bを比べ，最低何回押す必要があるか計算する．例では，  
* a = [4971, 7482, 1238, 8523, 1823]  
* b = [3287, 9013, 9812, 297, 1809]

である．a < b の場合は単純に b - a でOK．b < a の場合は10000まで進んで，1に戻ることを考慮すると，b - a + 10000になる．  
この場合は，[8316, 1531, 8574, 1774, 9986]となる．  
  
上で求めた最低回数ではなく，k周分余分に押す方が全体として押す回数が少なくなる場合がある．    

例えばこの例の場合，全てのカウンタを最低回数だけ押すときには，左からカウンタ0, 1, 2, 3, 4と呼ぶと，  
(1) カウンタ0・1・2・3・4　…　1531回　　残り[6785, 0, 7043, 243, 8455]  
(2) カウンタ2・3・4　　　　…　 243回　　残り[6785, 0, 6800, 0, 8212]  
(3) 残るカウンタを単体で押す．各6785，6800，8212回
カウンタを押した数は，1531 + 243 + 6785 + 6800 + 8212 = 23571 回となる．

次にカウンタ1とカウンタ3を1周分多く押すことにしよう．つまり，[8316, 11531, 8574, 11774, 9986]回押す場合である．このときは，  
(1) カウンタ0・1・2・3・4　…　8316回　　残り[0, 3215, 258, 3458, 1670]    
(2) カウンタ1・2・3・4　　 …　 258回　　残り[0, 2957, 0, 3200, 1412]  
(3) カウンタ3・4　　　　　 …　1412回　　残り[0, 2957, 0, 1788, 0]  
(4) 残るカウンタを単体で押す．各2957，1788回
カウンタを押した数は，8316 + 258 + 1412 + 2957 + 1788 = 14731 回となる．

したがってこの問題は，「各カウンタは最低回数＋k周分の回数押されるが，全体でのカウンタを押す回数が最小となるような各カウンタの k はいくつか？」を求める問題とみることもできる．

**では，この k は最大でいくつになるのであろうか？（この値が，実行速度に大きく関係するので，非常に重要）  **

全部のカウンタの最大値は共通なので，n個全部のカウンタを1周以上余分に押すことが，ボタンを押す最小回数になることはない（少なくとも1つのボタンは，k = 0である）．また隣り合うボタンがそれぞれ $k_1$周，$k_2$周余分に押すのが最適だとすると，$k_1$と$k_2$は2以上離れることはなく，離れても差は1である（$|k_1 - k_2| = 0$ or $1$）．したがって，kの範囲は0 ≦ k ≦ n - 1 で十分である．

カウンタ i に対して，目標値にするために押す回数の候補となる配列（リスト）c[i] を作成する．最低回数をc0とすると，続く要素は c0 + m, c0 + 2m, c0 + 3m, ..., c0 + (n-1)mである．つまり，c[i][j] = c0 + j * m である．カウンタiを目標値にするためには，カウンタiをc[i][0]～c[i][n-1]のどれかの回数押せばよい．今回の例だと次のようになる．
* c[0] = [8316, 18316, 28316, 38316, 48316]  
* c[1] = [1531, 11531, 21531, 31531, 41531]  
* c[2] = [8574, 18574, 28574, 38574, 48574]  
* c[3] = [1774, 11774, 21774, 31774, 41774]  
* c[4] = [9986, 19986, 29986, 39986, 49986]


続いて，カウンタiをc[i][k]回押して，かつカウンタiより左の全てのカウンタも目標値bになるための最低押下回数をd[i][k]とする（注意：d[i][k]は0～i-1のカウンタを押す回数も含まれる）．このd[i][k]をDPで求める．

帰納的に考える．まず一番左のカウンタ0だけに注目する．カウンタが1つしかないので，c[0][k]回押せばカウンタ0は目標値になるので，d[0][k] = c[0][k] になる．つまり，以下のようになる．
* d[0] = [8316, 18316, 28316, 38316, 48316]  


続いて隣のカウンタ1に注目する．具体的に例を用いて考えよう．  

* カウンタ1をc[1][0](= 1531)回押す場合
    * カウンタ0をc[0][k]回押す場合 (k = 0, 1, 2, 3, 4)
        c[1][0] < c[0][k]なので，カウンタ0をc[0][k]回押すうち，c[1][0]回カウンタ1も同時押しすれば，カウンタ0も1も目標値になる．  
        よって，カウンタ0をc[0][k]回押す場合，全部で d[0][k] 回押せばカウンタ0・1が目標値になる．
    * まとめ  
        d[1][0]はカウンタ1をc[1][0]回押して，カウンタ0も目標値にする最小回数であるので，  
        d[1][0] = min(d[0][0], d[0][1], d[0][2], d[0][3], d[0][4]) = 8316 となる．

* カウンタ1をc[1][1](= 11531)回押す場合
    * カウンタ0をc[0][0](= 8316)回押す場合
        c[1][1] > c[0][0]なので，c[0][0]回はカウンタ0・1同時押しし，残るc[1][1] - c[0][0]回はカウンタ1のみ押せば，カウンタ0も1も目標値になる．
        よって，カウンタ0をc[0][0]回押す場合，全部で d[0][0] + c[1][1] - c[0][0] (= 8316 + 11531 - 8316 = 11531)回押せばカウンタ0・1が目標値となる．
    * カウンタ0をc[0][k]回押す場合 (k = 1, 2, 3, 4)
        c[1][1] < c[0][k]なので，カウンタ0をc[0][k]回押すうち，c[1][1]回カウンタ1も同時押しすれば，カウンタ0も1も目標値になる．  
        よって，カウンタ0をc[0][k]回押す場合，全部で d[0][k] 回押せばカウンタ0・1が目標値になる．
    * まとめ  
        d[1][1]はカウンタ1をc[1][1]回押して，カウンタ0も目標値にする最小回数であるので，  
        d[1][1] = min(11531, d[0][1], d[0][2], d[0][3], d[0][4]) = 11531 となる．

以下同様に計算すると，d[1]は次のようになる．  
* d[0] = [8316, 18316, 28316, 38316, 48316]  
* d[1] = [8316, 11531, 21531, 31531, 41531]  


続いて隣のカウンタ2に注目する．具体的に例を用いて考えよう．  

* カウンタ2をc[2][0](= 8574)回押す場合
    * カウンタ1をc[1][0](= 1531)回押す場合
        c[2][0] > c[1][0]なので，c[1][0]回はカウンタ1・2同時押しし，残るc[2][0] - c[1][0]回はカウンタ2のみ押せば，カウンタ0～2も目標値になる．
        よって，カウンタ1をc[1][0]回押す場合，全部で d[1][0] + c[2][0] - c[1][0] (= 8316 + 8574 - 1531 = 15359)回押せばカウンタ0～2が目標値となる．
    * カウンタ1をc[1][k]回押す場合 (k = 1, 2, 3, 4)
        c[2][0] < c[1][k]なので，カウンタ1をc[1][k]回押すうち，c[2][0]回カウンタ2も同時押しすれば，カウンタ0～2も目標値になる．  
        よって，カウンタ1をc[1][k]回押す場合，全部で d[1][k] 回押せばカウンタ0～2が目標値になる．
    * まとめ  
        d[2][0]はカウンタ1をc[2][0]回押して，カウンタ0～2を目標値にする最小回数であるので，  
        d[2][0] = min(15359, d[1][1], d[1][2], d[1][3], d[1][4]) = 11531 となる．

* カウンタ2をc[2][1](= 18574)回押す場合
    * カウンタ1をc[1][k](k = 0, 1)回押す場合
        c[2][1] > c[1][k]なので，c[1][k]回はカウンタ1・2同時押しし，残るc[2][1] - c[1][k]回はカウンタ2のみ押せば，カウンタ0～2も目標値になる．
        よって，カウンタ1をc[1][k]回押す場合，全部で d[1][k] + c[2][1] - c[1][k] 回押せばカウンタ0～2が目標値となる．  
        具体的には，k = 0のとき，8316 + 18574 - 1531 = 25359，k = 1のとき，11531 + 18574 - 11531 = 18574．
    * カウンタ1をc[1][k]回押す場合 (k = 2, 3, 4)
        c[2][1] < c[1][k]なので，カウンタ1をc[1][k]回押すうち，c[2][1]回カウンタ2も同時押しすれば，カウンタ0～2も目標値になる．  
        よって，カウンタ1をc[1][k]回押す場合，全部で d[1][k] 回押せばカウンタ0～2が目標値になる．
    * まとめ  
        d[2][1]はカウンタ1をc[2][1]回押して，カウンタ0～2を目標値にする最小回数であるので，  
        d[2][1] = min(25359, 18574, d[1][2], d[1][3], d[1][4]) = 18574 となる．

以下同様に計算すると，d[2]は次のようになる．  
* d[0] = [8316, 18316, 28316, 38316, 48316]  
* d[1] = [8316, 11531, 21531, 31531, 41531]  
* d[2] = [11531, 18574, 28574, 38574, 48574]


カウンタ3・4に対して，同様にd[3], d[4]を求める．
* d[0] = [8316, 18316, 28316, 38316, 48316]  
* d[1] = [8316, 11531, 21531, 31531, 41531]  
* d[2] = [11531, 18574, 28574, 38574, 48574]
* d[3] = [11531, 14731, 21774, 31774, 41774]
* d[4] = [14731, 21774, 29986, 39986, 49986]

よって，d[4]の中の最小値 14731 回押せば，カウンタ0～4までを最小回数で目標値にできる．


上の手順を一般化する．カウンタ i を k 周余分に押す場合に，カウンタ0～iのすべてを目標値にする最小押下回数 d[i][k]は，  
* d[0][k] = c[0][k]  
であり，i>0に対して，  
* d[i][k] = min{ dd[i][k][l] for l = 0, 1, ..., m-1}  
* dd[i][k][l] = d[i-1][l]  (c[i][k] < c[i-1][l]のとき）  
　　　　　　d[i-1][l] + c[i][k] - c[i-1][l] 　（その他のとき）  
である．ここで，dd[i][k][l]は，ボタン i は k 周余分に，ボタン i-1 は l 周余分に押す場合に，カウンタ0～iのすべてを目標値にする最小押下回数である．


```python
while True:

    n, m = list(map(int, input().split()))
    if m == 0 and n == 0:
        break

    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    # ボタン i を b[i] にするために最低限必要な押す回数
    c0 = [ b[i] - a[i] if b[i] >= a[i] else b[i] - a[i] + m for i in range(n)]
    # print('c0 =', c0)
    if sum(c0) == 0:    #既に達成
        print(0)
        continue

    # ボタン i を（k周余分に）押す回数を表す2次元リスト c[i][k] を作成
    c = [ [ c0[i] + k * m for k in range(n) ] for i in range(n) ]
    # print('c =', c)

    # ボタン i を c[i][k]回押して，ボタン i とその前のボタンを目標値 b にする最低回数 d[i][k]
    d = [ [None] * n for i in range(n)]   # リスト枠作成
    d[0][0] = c[0][0]       # 一番前のボタンの設定
    max_k = [( (n-1) - abs(2 * i - (n-1)) ) // 2 for i in range(n)]

    # DPで構築
    for i in range(1, n):       # 前から2番目以降，順次作成
        for k in range(max_k[i] + 1):      # d[i][k]を計算
            d_kouho = []
            for kk in range(n): # 一つ前の i-1 番目のボタンに対する c[i-1][kk], d[i-1][kk]を参照
                if d[i-1][kk] is None:
                    break       # 前のボタンをこれ以上調べる必要なし
                # ボタンを押す回数の方が前のボタンより少ないとき → 前のボタンと同時押しで対応可能
                if c[i][k] <= c[i-1][kk]:
                    d_kouho.append(d[i-1][kk])
                    break   # 前のボタンをもう一周させても，数が増えるだけなのでチェック不要
                # ボタンを押す回数の方が前のボタンより多いとき → 前のボタンと同時押し＋不足分を押す
                else:
                    d_kouho.append(d[i-1][kk] + c[i][k] - c[i-1][kk])
            d[i][k] = min(d_kouho)
            if k > 0 and d[i][k] == d[i][k-1] + m:   # 求まった回数が，単純に一周分多いとき → これ以降は不要
                d[i][k] = None
                break
    #print('d =', d)
    print(min(e for e in d[n-1] if e is not None))

```

上で記した処理に加え，計算時間短縮のための工夫を施していますが，AOJでは実行時間オーバーになってしまいます．．．（正答を出力はできているようです）

## 追記（2019/11/22,2019/12/06） 

上のプログラムでd[i][k] = min(d_kouho) としている箇所があるが，最小値になるkkは2パターンしかないことに注目する．
- c[i-1][k] < c[i][k] のとき，c[i-1][k] < c[i][k] < c[i-1][k+1]なので，kk = k, k+1
- c[i-1][k] > c[i][k] のとき，c[i-1][k-1] < c[i][k] < c[i-1][k]なので，kk = k-1, k

これによって，kkに関するループの回数を減らすことが可能（AOJでもクリアできます）．

```python
while True:

    n, m = list(map(int, input().split()))
    if m == 0 and n == 0:
        break

    a = list(map(int, input().split()))
    b = list(map(int, input().split()))

    # ボタン i を b[i] にするために最低限必要な押す回数
    # c0 = [ (bi - ai) % m for ai, bi in zip(a, b)]
    c = [ (bi - ai) % m for ai, bi in zip(a, b)]
    # print('c0 =', c0)

    # ボタン i を（k周余分に）押す回数を表す2次元リスト c[i][k] を作成
    max_k = (n - 1) // 2        # もっと小さくできる？
    # c = [ [ c0[i] + k * m for k in range(max_k + 1) ] for i in range(n) ]
    # print('c =', c)

    # ボタン i を c[i][k]回押して，ボタン i とその前のボタンを目標値 b にする最低回数 d[i][k]
    d = [ [0] * (max_k + 1) for i in range(n)]   # リスト枠作成
    # d[0] = c[0]       # 一番前のボタンの設定
    d[0] = [ c[0] + k * m for k in range(max_k + 1) ]       # 一番前のボタンの設定

    # DPで構築
    for i in range(1, n):       # 前から2番目以降，順次作成
        if c[i-1] > c[i]:     # 前のcの方が大きい場合
            d[i][0] = d[i-1][0]     # 前のボタンと同時押しでこのボタンは押せる
            for k in range(1, max_k + 1):
                # k周余分に押す場合は，前ボタンk周で同時押し or 前ボタンk-1周で同時押し＋不足分押し
                d[i][k] = min(d[i-1][k], d[i-1][k-1] + c[i] + m - c[i-1])
        else:                       # 前のcの方が小さい場合
            for k in range(max_k):
                # k周余分に押す場合，前ボタンk+1周で同時押し or 前ボタンk周で同時押し＋不足分押し
                d[i][k] = min(d[i-1][k+1], d[i-1][k] + c[i] - c[i-1])
            # max_k周余分に押す場合は，前ボタンmax_k周で同時押し＋不足分押しのみ
            d[i][max_k] = d[i-1][max_k] + c[i] - c[i-1]

    # print('d =', d)
    print(min(d[n-1]))
```


